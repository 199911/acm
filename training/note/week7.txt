CUHK ACM SUMMER TRAINING 2012
Week 7 

Speaker: Lapchi
Scribe: David

Topics:
1. Eulerian Cycle/Path
2. Bipartite Matching and Application
3. Maximum Flow 

Details:

1. Eulerian Cycle/Path
  1.1. Definition:
    Given an undericted graph G, an Eulerian Cycle C on G is a cycle that traverse each edges exactly once. A graph that has a Eulerian Cycle is called Eulerian Graph.

  1.2 How to Determine if a graph is Eulerian?
    A undirected graph is an Eulerian graph if and only if:
      (1) every vertices has even degree.
      (2) it has only one connected component that has more than one vertices.

    Remark: 
      An Eulerian graph can be disconnected if those "disconnected components" are just isolated points.

  1.3 How to find an Eulerian Cycle.
    Eulerian Cycle problem is solvable in linear time. The algorithm is due to Hierholzer in 1873. 
      (1) Choose any starting vertex v, and follow a trail of edges from that vertex until returning to v. It is not possible to get stuck at any vertex other than v, because the even degree of all vertices ensures that, when the trail enters another vertex w there must be an unused edge leaving w. The tour formed in this way is a closed tour, but may not cover all the vertices and edges of the initial graph.
      (2) As long as there exists a vertex u that belongs to the current tour but that has adjacent edges not part of the tour, start another trail from v, following unused edges until returning to v, and join the tour formed in this way to the previous tour.

    How to choose the vertices u and the untraversed edges adjacent to v can determine the property of the resultant path. If we choose the last vertices along the cycle from v, and choose the smallest indexed untraversed vertices from u, the resultant path will be lexicographically smallest (in terms of vertices). 

  1.4 Implementation:
    We can implement Lex-Smallest Euler Path in linear time using DFS. It's a nice exercies to reason why the implementation is correct. 

    ---------------------------------------------
    // find the lex smallest (in terms of vertices) euler cycle

    #define N 111
    #define M 111111

    // graph in adj list
    int adj[N][N], cur[N], n, m;
    int hd, nt[M], vtx[M], cnt;

    void init() {
      memset(adj, 0, sizeof(adj));
      memset(cur, 0, sizeof(cur));
      hd = -1;
      memset(nt, -1, sizeof(nt));
      cnt = 0;
    }

    void push( int x ) {
      nt[cnt] = hd;
      vtx[cnt] = x;
      hd = cnt++;
    }

    void dfs(int x) {
      for (int &v = cur[x]; v < n; v++) {
        if ( adj[x][v] > 0 ) {
          adj[x][v]--;
          if ( x != v ) adj[v][x]--;
          dfs( v );
          push( x );
        }
      }
    }

    int main() {
      scanf( "%d%d", &n, &m );
      init();
      REP(i, m) {
        int a, b;
        scanf( "%d%d", &a, &b );
        adj[a][b] = adj[b][a] = 1;
      }
      push(0);
      dfs(0);
      for( int e = hd; e != -1; e = nt[e] ) printf( "%d\n", vtx[e] );
      return 0;
    }
    ---------------------------------------------

    The running time for the above implementation is O(V^2 + E), while an implementation using adjacency list can make the running time O(V+E).


  1.5 Directed Eulerian Cycle. 

    A directed graph have an Eulerian Cycle if an only if the in degree is equal to the out degree for all vertices and at most one strongly connected component has more than one vertex.

    The adaptation of above algorithm is left as an exercise.

  1.6 Homework:
    * UVA 10054
    * UVA 302

	1.7 Reference
		wikipedia: http://en.wikipedia.org/wiki/Eulerian_path
		http://www.csie.ntnu.edu.tw/~u91029/Circuit.html


2 Bipartite Matching
  2.1 Definition
    A graph G = (V, E) is bipartite if we can partition the set V into two disjoint subset A \union B such that every edge has exactly one end point in A and one end point in B. 
    Given an undirected graph G = ( V, E ), a matching M is a subset of E such that each vertex in V is adjacent to at most one edges in M.

    The Maximum Bipartite Matching problem is stated as, given an undirected bipartite graph G, find a matching of maximum size. 

  2.2 Approach
    2.2.1 Some New Definition
      (1) Exposed Vertex: 
        Given a matching M, an exposed vertex v w.r.t. M is a vertex that is not matched in M. 
      (2) Residue Graph: 
        Given an undirected bipartite graph G = ( A + B, E ), and a matching M on G, the resiude graph of G, says G' w.r.t. M is the directed graph on the same set of vertices with edges of the following:
          * ( a, b ) for a \in A and b \in B and (a, b) \not\in M.
          * ( x, y ) for x \in B and y \in A and (x, y) \in M.
      (3) Augmenting Path.
        An augmenting path on G' is the path from an exposed vertex in A to an exposed vertex in B.

    2.2.2 Observations:
      Observation 1:
        If G' contain some augmenting path P, the M is not optimal and we can augment matching M by 1 by letting M = ( M - P ) + ( P - M ) (a.k.a taking the symmetric difference of P and M) (a.k.a taking the edges in M but not in P union with the edges in P but not in M).

      Proof is left as an exercise.

      Observation 2: 
        Given two matching M and M' with |M| < |M'| on G, there exists an augmenting path w.r.t. M in G'.

      Prooof:
        We construct the graph with vertex set V and edges set (M - M) + (M' - M). We orient the edges from M going from B to A and the edges from M' going from A to B (as in residue graph). Then since |M-M'| < |M'-M|, and every path from an exposed vertices from A to a matched vertices in A takes up some number of edges in M as in M', there must be a path from an exposed vertex in A to an exposed vertex in B, which is an augmenting path.

    2.2.3 Solution:
      The above observation yields a simple algorithm for the problem:
    -------------------------------------------------------------------
        while( there is still an augmenting path in the residue graph )
          augment the matching by 1 from the augmenting path;
    -------------------------------------------------------------------

    2.2.4 Implementation
      -------------------------------------------------------------------
      #define N 222

      int adj[N][N], na, nb, m;

      int ma[N], mb[N], va[N], vb[N];

      void init() {
        memset(adj, 0, sizeof(adj));
        m = na = nb = 0;
        memset(ma, -1, sizeof(ma));
        memset(mb, -1, sizeof(mb));
      }

      int path(int x) {
        va[x] = 1;
        for(int y = 0; y < nb; y++) {
          if( adj[x][y] && !vb[y] ) {
            vb[y] = 1;
            if( mb[y] == -1 || path(mb[y]) ) {
              ma[x] = y; mb[y] = x; 
              return 1;
            }
          }
        }
        return 0;
      }

      int bmatch() {
        int cnt = 0;
        REP(x, na) {
          memset(va, 0, sizeof(va));
          memset(vb, 0, sizeof(vb));
          cnt += path(x);
        }
        return cnt;
      }
      -------------------------------------------------------------------

  2.3 Application
    (1) Tile Covering
      Given a grid [1, n] * [1, m], with some sqare (x, y) broken, is it possible to tile up all the remaining grid with a 1 * 2 tile?

    (2) Graph Orientation
      Given an undirected graph G, and an orientation of a subset of edges, is it possible to orient the remaining edges such that the resultant graph has a directed Eulerian cycle.

    (3) Cycle Cover
      Given an directed graph, is it possible to cover the graph with edge disjoint directed cycle?

  2.4 Homework
    UVA 753 http://uva.onlinejudge.org/external/7/753.html
    UVA 10092 http://uva.onlinejudge.org/external/100/10092.html

	2.5 Reference:
		http://www.csie.ntnu.edu.tw/~u91029/Matching.html
		www-math.mit.edu/~goemans/.../matching-notes.pdf
		http://en.wikipedia.org/wiki/Matching_%28graph_theory%29

3. Maximum Flow
  
  3.1 Motivation
    The problem was motivated from a very simple setting. Suppose we have a bunch of water pipe with different capacity, connected by junctions. Given a source and a sink, how much water per second we can send from the source to the sink?

  3.2 Definition
		A flow network is a 4-tuples (G, c, s, t), where G is an undirected graph, c:E -> R+ is a capacity function for set of edges. s and t is two distinct vertices from G where s is the source and t is the sink.
		Moreover, we make the restriction that one of c(u, v) or c(v, u) must be zero.

		A flow function for a flow network is a function f:E->R satisfying the following proporties:
			(1) flow Conservation: 
				For all x \in V - {s, t}
				\sum_{ (y, x) \in E } f(y, x) = \sum_{ (x, y) \in E } f(x, y)
			(2) skew symmetric 
				f(x, y) = -f(y, x)
			(3) capacity constraint
				f(x, y) <= c(x, y)

		It's not difficult to prove that the total flow going out of s, denoted by f(s, V), equals the total flow going inside the sink, denoted by f(V, t). (details in CLRS)

		Then the MAXIMUM FLOW problem asks you to maximize the total amount of flow going from s to t.

	3.3 Augmenting Path Approach. 
		Similar to maximum matching problem, we can solve MAXIMUM FLOW problem using the augmenting path approach. We given a flow network (G = (V, E), c, s, t) and a flow f, we define the following
		
		The Residue Network (G, c', s, t) w.r.t. f is defined as 
			c'(u, v) = c(u, v) - f(u, v).

		Then an augmenting path is a path with nonzero capacity in the residue network going from s to t. To visuallize the definition, we can think of how we can increase our flow f. We can either push some flow towards (u, v) if the edges is not saturated, or we can push some flow backwards, (v, u), to cancel out some original flow in (u, v). The capacity is c(u, v) - f(u, v), and f(u, v) = -f(v, u) respectively.

		Then The Augmenting Path Theorem state that
			A flow f is maximum if and only if there is no s-t augmenting path in the residue network w.r.t. f. 

		The proof of the theorem can be seen in CLRS.

	3.4 Algorithm
		Then we have a very simple algorithm for solving MAXIMUM FLOW problem:
		----------------------------------------------
			while( there is an augmenting path in the residue network )
				augment the flow from the augmenting path by c where c is the minimum capacity of the path
		----------------------------------------------

	3.5 C++ Implementation
		the C++ implementation uses a nice trick that is often used in undirected graph, i.e. for every edges, (u, v), we would like to efficiently O(1) find the edge (v, u). While this is trivial if we use adjacency matrix, finding the reversed edges can be trickly if we just we adjacency list.

		The idea of this trick is to allocate the space for (u, v) and (v, u) consecutively, so if e is pointing to (u, v), e^1 will be pointing to (v, u).


